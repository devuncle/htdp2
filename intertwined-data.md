# 纠缠在一起的数据

您可能会认为列表和自然数的数据定义非常不寻常。这些数据定义是自指的，很可能是您遇到的第一个此类定义。事实证明，许多数据类别都需要比这两种更为复杂的数据定义。通用概括涉及在一个数据定义或一堆互相引用的数据定义中的许多自引用。这些数据形式已经无处不在，因此对于程序员来说，学会应对任何数据定义集合都是至关重要的。这就是设计诀窍的全部内容。

这一部分从设计秘诀的一般化开始，以便它适用于所有形式的结构数据定义。接下来，它从“项目”中引入迭代细化的概念：严格列出列表，因为复杂的数据定义不是一口气就能开发出来的，而是分几个阶段来开发的。确实，使用迭代改进是所有程序员都不是科学家的原因之一，也是我们的学科在其美国名称中使用“科学”一词的原因之一。最后两章说明了这些想法：一章介绍了如何为BSL设计解释器，另一章介绍了如何处理XML（一种Web数据交换语言）。上一章再次扩展了设计秘诀，将其重新设计用于可同时处理两个复杂参数的函数。

## 19 s表达式的诗歌

编程类似于诗歌。 像诗人一样，程序员在看似毫无意义的想法上练习技巧。 如上一章所述，它们一直在进行修改和编辑。 本章介绍了越来越复杂的数据形式-似乎没有现实目的。 即使我们提供了动机背景，所选择的数据类型也非常纯净，您再也不会遇到它们。

但是，本章将展示设计方法的全部功能，并向您介绍实际程序所能处理的各种数据。 为了将这些资料与您在程序员生活中会遇到的东西联系起来，我们用适当的名称标记每个部分：树，森林，XML。 最后一个有点误导，因为它实际上与S表达式有关。 S表达式和XML之间的联系在《项目：XML的商业》中得到了阐明，与本章相反，它与现实世界中对复杂数据形式的使用更加接近。

### 19.1 树

我们所有人都有一棵家谱。 绘制家谱的一种方法是，每当孩子出生时添加一个元素，并连接父母的元素。 对于那些父母不认识的人来说，没有绘画的联系。 结果就是祖先家谱，因为该树指向任何人，都指向该人的所有已知祖先。

没有尽头。 为了避免这种无意义的数据定义，我们要求自引用数据定义包含多个子句，并且其中至少有一个不引用该数据定义。
让我们暂时推迟一下数据定义，然后尝试一下。 假设我们要将一个孩子添加到现有的家谱中，并且已经有父母的表示形式。 在这种情况下，我们可以简单地构造一个新的子结构。 例如，要在已经代表Carl和Bettina的程序中代表Adam，只需添加以下子结构即可：

我们的实验提出了两种见解。 首先，我们不是在寻找描述如何生成子结构实例的数据定义，而是在寻找描述如何表示家族树的数据定义。 其次，数据定义由两个子句组成，一个子句用于描述未知家族树的变量，另一个子句用于已知家族树：

首先，我们不着眼于在家谱上设计具体的功能，而是查看此类功能的一般组织。 也就是说，在不考虑具体任务的情况下，让我们尽可能多地研究设计诀窍。 我们从标题材料开始，即配方的第2步：

现在我们准备定义实际功能。该函数区分两种情况：无父母和有子女。对于第一种情况，即使我们没有提供任何示例，答案也应该显而易见。由于给定的家谱不包含任何子级，因此不能包含以“蓝色”作为眼睛颜色的子级。因此，第一个cond子句中的结果为#false。

对于第二个cond子句，设计需要做很多工作。再次遵循设计秘诀，我们首先提醒自己模板中的表达式完成了什么：
根据功能的目的说明，
（蓝眼睛的孩子？（儿童父亲antree）

确定父亲的FT中的某个孩子是否有“蓝眼睛”；
同样，（蓝眼睛的孩子？（儿童母亲的后代））确定母亲FT中的某人是否有蓝眼睛；和

选择器表达式（child-name an-ftree），（child-date an-ftree）和（child-eyes an-ftree）分别从给定的子结构中提取名称，出生日期和眼睛颜色。

现在我们只需要弄清楚如何组合这些表达式。
显然，如果子结构在“眼睛”字段中包含“蓝色”，则该函数的答案为#true。接下来，关于名称和出生日期的表达式是无用的，这使我们有了递归调用。如前所述，（蓝眼睛的孩子？（孩子-父亲an-ftree））穿过父亲一侧的树，而家谱的母亲一侧则经过处理（“蓝眼睛的孩子？（孩子-母亲和孩子）”）。 -ftree））。如果这些表达式中的任何一个返回#true，则an-ftree包含一个眼睛为“蓝”的孩子。

### 19.2 Forests

It is a short step from a family tree to a family forest:

```racket
; An FF (short for family forest) is one of: 
; – '()
; – (cons FT FF)
; interpretation a family forest represents several
; families (say, a town) and their ancestor trees
```

**问题示例**设计函数“森林中的蓝眼睛的孩子”？该函数确定家庭森林中是否包含在视场中带有“蓝色”的孩子。

简单的解决方案如图115所示。您可以自己研究签名，目的陈述和示例。我们专注于计划组织。关于模板，设计可以使用列表模板，因为该功能会消耗列表。如果列表中的每个项目都是带有眼睛区域的结构，则该函数将使用针对眼睛区域的选择器功能和字符串比较在这些结构上进行迭代。在这种情况下，每个项目都是一棵家谱，但是幸运的是，我们已经知道如何处理家谱。

让我们退后一步，看看我们如何解释图115。起点是一对数据定义，其中第二个引用第一个，两个都引用自己。结果是一对函数，其中第二个引用第一个，两个都引用自己。换句话说，函数定义相互引用的方式与数据定义相互引用的方式相同。前面的章节掩盖了这种关系，但是现在情况非常复杂，值得关注。

### 19.3 S-expressions

; An S-expr is one of: 
; – Atom
; – SL
 
; An SL is one of: 
; – '()
; – (cons S-expr SL)

; An Atom is one of: 
; – Number
; – String
; – Symbol 

S表达式的概念归因于John McCarthy和他的Lispers，他们于1958年创建了S表达式，以便他们可以与其他Lisp程序一起处理Lisp程序。 这种看似循环的推理听起来似乎有些深奥，但正如Intermezzo 2：Quote，Unquote中所提到的那样，S表达式是一种通用的数据形式，经常会被重新发现，最近一次是在万维网上的应用。 因此，使用S表达式可为如何为高度相互关联的数据定义设计函数的讨论做准备。

到这本书为止，没有数据需要像S表达式那样复杂的数据定义。 然而，有一个额外的提示，如果您遵循设计秘诀，则可以设计处理S表达式的函数。 为了说明这一点，让我们来看一个具体的例子：
样本问题设计函数计数，该函数计数确定某些符号在某些S表达式中出现多少次。

尽管第一步要求进行数据定义并且似乎已经完成，但是请记住，它还要求创建数据示例，尤其是在定义复杂时。

## 20 迭代细化

## 21 细化解释器

## 22 xml的商业

## 23 同时处理

## 24 总结

