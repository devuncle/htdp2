# 纠缠在一起的数据

您可能会认为列表和自然数的数据定义非常不寻常。这些数据定义是自指的，很可能是您遇到的第一个此类定义。事实证明，许多数据类别都需要比这两种更为复杂的数据定义。通用概括涉及在一个数据定义或一堆互相引用的数据定义中的许多自引用。这些数据形式已经无处不在，因此对于程序员来说，学会应对任何数据定义集合都是至关重要的。这就是设计诀窍的全部内容。

这一部分从设计秘诀的一般化开始，以便它适用于所有形式的结构数据定义。接下来，它从“项目”中引入迭代细化的概念：严格列出列表，因为复杂的数据定义不是一口气就能开发出来的，而是分几个阶段来开发的。确实，使用迭代改进是所有程序员都不是科学家的原因之一，也是我们的学科在其美国名称中使用“科学”一词的原因之一。最后两章说明了这些想法：一章介绍了如何为BSL设计解释器，另一章介绍了如何处理XML（一种Web数据交换语言）。上一章再次扩展了设计秘诀，将其重新设计用于可同时处理两个复杂参数的函数。

## 19 s表达式的诗歌

编程类似于诗歌。 像诗人一样，程序员在看似毫无意义的想法上练习技巧。 如上一章所述，它们一直在进行修改和编辑。 本章介绍了越来越复杂的数据形式-似乎没有现实目的。 即使我们提供了动机背景，所选择的数据类型也非常纯净，您再也不会遇到它们。

但是，本章将展示设计方法的全部功能，并向您介绍实际程序所能处理的各种数据。 为了将这些资料与您在程序员生活中会遇到的东西联系起来，我们用适当的名称标记每个部分：树，森林，XML。 最后一个有点误导，因为它实际上与S表达式有关。 S表达式和XML之间的联系在《项目：XML的商业》中得到了阐明，与本章相反，它与现实世界中对复杂数据形式的使用更加接近。

### 19.1 树

我们所有人都有一棵家谱。 绘制家谱的一种方法是，每当孩子出生时添加一个元素，并连接父母的元素。 对于那些父母不认识的人来说，没有绘画的联系。 结果就是祖先家谱，因为该树指向任何人，都指向该人的所有已知祖先。

没有尽头。 为了避免这种无意义的数据定义，我们要求自引用数据定义包含多个子句，并且其中至少有一个不引用该数据定义。
让我们暂时推迟一下数据定义，然后尝试一下。 假设我们要将一个孩子添加到现有的家谱中，并且已经有父母的表示形式。 在这种情况下，我们可以简单地构造一个新的子结构。 例如，要在已经代表Carl和Bettina的程序中代表Adam，只需添加以下子结构即可：

我们的实验提出了两种见解。 首先，我们不是在寻找描述如何生成子结构实例的数据定义，而是在寻找描述如何表示家族树的数据定义。 其次，数据定义由两个子句组成，一个子句用于描述未知家族树的变量，另一个子句用于已知家族树：

首先，我们不着眼于在家谱上设计具体的功能，而是查看此类功能的一般组织。 也就是说，在不考虑具体任务的情况下，让我们尽可能多地研究设计诀窍。 我们从标题材料开始，即配方的第2步：

现在我们准备定义实际功能。该函数区分两种情况：无父母和有子女。对于第一种情况，即使我们没有提供任何示例，答案也应该显而易见。由于给定的家谱不包含任何子级，因此不能包含以“蓝色”作为眼睛颜色的子级。因此，第一个cond子句中的结果为#false。

对于第二个cond子句，设计需要做很多工作。再次遵循设计秘诀，我们首先提醒自己模板中的表达式完成了什么：
根据功能的目的说明，
（蓝眼睛的孩子？（儿童父亲antree）

确定父亲的FT中的某个孩子是否有“蓝眼睛”；
同样，（蓝眼睛的孩子？（儿童母亲的后代））确定母亲FT中的某人是否有蓝眼睛；和

选择器表达式（child-name an-ftree），（child-date an-ftree）和（child-eyes an-ftree）分别从给定的子结构中提取名称，出生日期和眼睛颜色。

现在我们只需要弄清楚如何组合这些表达式。
显然，如果子结构在“眼睛”字段中包含“蓝色”，则该函数的答案为#true。接下来，关于名称和出生日期的表达式是无用的，这使我们有了递归调用。如前所述，（蓝眼睛的孩子？（孩子-父亲an-ftree））穿过父亲一侧的树，而家谱的母亲一侧则经过处理（“蓝眼睛的孩子？（孩子-母亲和孩子）”）。 -ftree））。如果这些表达式中的任何一个返回#true，则an-ftree包含一个眼睛为“蓝”的孩子。

### 19.2 Forests

It is a short step from a family tree to a family forest:

```racket
; An FF (short for family forest) is one of: 
; – '()
; – (cons FT FF)
; interpretation a family forest represents several
; families (say, a town) and their ancestor trees
```

**问题示例**设计函数“森林中的蓝眼睛的孩子”？该函数确定家庭森林中是否包含在视场中带有“蓝色”的孩子。

简单的解决方案如图115所示。您可以自己研究签名，目的陈述和示例。我们专注于计划组织。关于模板，设计可以使用列表模板，因为该功能会消耗列表。如果列表中的每个项目都是带有眼睛区域的结构，则该函数将使用针对眼睛区域的选择器功能和字符串比较在这些结构上进行迭代。在这种情况下，每个项目都是一棵家谱，但是幸运的是，我们已经知道如何处理家谱。

让我们退后一步，看看我们如何解释图115。起点是一对数据定义，其中第二个引用第一个，两个都引用自己。结果是一对函数，其中第二个引用第一个，两个都引用自己。换句话说，函数定义相互引用的方式与数据定义相互引用的方式相同。前面的章节掩盖了这种关系，但是现在情况非常复杂，值得关注。

### 19.3 S-expressions

; An S-expr is one of: 
; – Atom
; – SL
 
; An SL is one of: 
; – '()
; – (cons S-expr SL)

; An Atom is one of: 
; – Number
; – String
; – Symbol 

S表达式的概念归因于John McCarthy和他的Lispers，他们于1958年创建了S表达式，以便他们可以与其他Lisp程序一起处理Lisp程序。 这种看似循环的推理听起来似乎有些深奥，但正如Intermezzo 2：Quote，Unquote中所提到的那样，S表达式是一种通用的数据形式，经常会被重新发现，最近一次是在万维网上的应用。 因此，使用S表达式可为如何为高度相互关联的数据定义设计函数的讨论做准备。

到这本书为止，没有数据需要像S表达式那样复杂的数据定义。 然而，有一个额外的提示，如果您遵循设计秘诀，则可以设计处理S表达式的函数。 为了说明这一点，让我们来看一个具体的例子：
样本问题设计函数计数，该函数计数确定某些符号在某些S表达式中出现多少次。

尽管第一步要求进行数据定义并且似乎已经完成，但是请记住，它还要求创建数据示例，尤其是在定义复杂时。

### 19.5 Project: BSTs

程序员通常使用数据的树表示形式来改善其功能的性能。 树的一种特别著名的形式是二进制搜索树，因为它是快速存储和检索信息的好方法。

(define-struct no-info [])
(define NONE (make-no-info))
 
(define-struct node [ssn name left right])
; A BT (short for BinaryTree) is one of:
; – NONE
; – (make-node Number Symbol BT BT)

换句话说，要检查BT是否也属于BST，我们必须检查所有子树中的所有数字，并确保它们小于或大于给定的数字。 这给数据的构建带来了额外的负担，但是，如以下练习所示，这是非常值得的。

在BST中寻找具有给定ssn的节点可能会利用BST不变性。 为了找出BT是否包含具有特定ssn的节点，功能可能必须查看树的每个节点。 相反，为了找出二叉搜索树是否包含相同的ssn，函数可以针对其检查的每个节点消除两个子树之一。

让我们用这个示例BST来说明这个想法：
（make节点66'a L R）

如果我们正在寻找66，我们已经找到了我们正在寻找的节点。 现在，如果我们要查找较小的数字（例如63），则可以将搜索集中在L上，因为ssn字段小于66的所有节点都在L中。类似地，如果要查找99，我们将忽略L并关注 在R上是因为ssns大于66的所有节点都在R中。

### 19.6 Simplifying Functions

## 20 迭代细化

在开发实际程序时，您可能会遇到复杂的信息形式以及用数据表示它们的问题。解决此任务的最佳策略是使用迭代优化，这是众所周知的科学过程。科学家的问题是要使用某种形式的数学来代表现实世界的一部分。努力的结果称为模型。然后，科学家以多种方式测试模型，特别是通过预测实验结果。如果预测和测量之间的差异太大，则以改善预测为目标来完善模型。该迭代过程将继续进行，直到预测足够准确为止。

考虑一个希望预测火箭飞行路线的物理学家。尽管“火箭作为一个点”表示很简单，但它也很不准确，例如无法考虑空气摩擦。作为响应，物理学家可以添加火箭的大致轮廓，并引入必要的数学来表示摩擦。第二个模型是第一个模型的改进。一般而言，科学家会重复进行此过程（或按照程序员的说法进行迭代），直到模型以足够的精度预测火箭的飞行路径为止。

在计算机科学系受过训练的程序员应像这位物理学家一样继续前进。关键是找到真实信息和正确处理它们的功能的准确数据表示形式。复杂的情况要求完善过程以结合适当的功能获得足够的数据表示。该过程从基本信息开始，然后根据需要添加其他信息。有时，由于用户要求其他功能，因此程序员必须在部署程序后优化模型。

到目前为止，在涉及复杂数据形式时，我们已经为您使用了迭代优化。本章通过扩展示例说明迭代优化，将其作为程序开发的原理，以表示和处理（部分）计算机文件系统。我们从对文件系统的简短讨论开始，然后迭代开发三种数据表示形式。在此过程中，我们提出了一些编程练习，以便您了解设计秘诀还如何帮助修改现有程序。

### 20.1 Data Analysis

在大多数计算机系统上，文件组织在目录或文件夹中。 粗略地说，目录包含一些文件和更多目录。 后者称为子目录，可能包含更多子目录和文件。 由于层次结构，我们谈到目录树。

图123包含一棵小目录树的图形草图，该图说明了为什么计算机科学家将其称为树。 与计算机科学中的惯例相反，该图显示了该树向上生长，并带有一个名为TS的根目录。 根目录包含一个名为read！的文件，以及两个分别称为Text和Libs的子目录。 第一个子目录Text仅包含三个文件。 后者Libs仅包含两个子目录，每个子目录至少包含一个文件。 最后，每个框都有两个注释之一：目录用DIR注释，文件用数字（大小）数字注释。

### 20.2 Refining Data Definitions

## 21 细化解释器

DrRacket是一个程序。这是一个复杂的数据，处理许多不同种类的数据。像大多数复杂的程序一样，DrRacket也包含许多功能：一个允许程序员编辑文本的功能，另一个像交互区域一样工作的功能，第三个用于检查定义和表达式是否“语法”的功能等等。

在本章中，我们将向您展示如何设计实现交互区域核心的功能。自然地，我们对该设计项目使用迭代优化。实际上，专注于DrRacket的这一方面的想法是另一种改进的实例，即，仅实现一项功能的显而易见的想法。

简而言之，交互区域执行确定输入的表达式值的任务。单击“运行”后，交互区域将了解所有定义。然后可以接受可能引用这些定义的表达式，确定该表达式的值，并根据需要多次重复此循环。因此，许多人也将交互区域称为read-eval-print循环，其中eval表示评估程序，该功能也称为解释程序。

像本书一样，我们的优化过程从数字BSL表达式开始。它们很简单；他们不承担对定义的理解；甚至您五年级的妹妹都可以确定他们的价值。理解了第一步之后，您就知道了BSL表达式及其表示形式之间的区别。接下来，我们进入带有变量的表达式。最后一步是添加定义。

### 21.1 Interpreting Expressions

我们的首要任务是就BSL程序的数据表示形式达成共识。 也就是说，我们必须弄清楚如何将BSL表达式表示为一条BSL数据。 起初，这听起来很奇怪和不同寻常，但这并不困难。 假设我们只想表示一个数字，加法和乘法。 显然，数字可以代表数字。 但是，加法表达式需要复合数据，因为它包含两个表达式并且因为它不同于乘法表达式，乘法表达式也需要数据表示。

### 21.2 Interpreting Variables

### 21.3 Interpreting Functions

至此，您了解了如何评估由常量定义和变量表达式组成的BSL程序。自然地，您希望添加函数定义，以便至少在原理上知道如何处理所有BSL。

本部分的目的是优化解释变量的评估程序，使其可以处理函数。由于函数定义显示在定义区域中，因此描述改进的求值器的另一种方法是，当定义区域包含许多函数定义并且程序员在包含这些函数用途的交互区域中输入表达式时，它可以模拟DrRacket。 。

为简单起见，我们假设定义区域中的所有函数都使用一个参数，并且只有一个这样的定义。必要的领域知识可以追溯到学校，在这里您了解到f（x）= e表示函数f的定义，f（a）表示f在a上的应用，并且要评估后者，您可以用a代替x在e。事实证明，使用诸如BSL之类的语言对功能应用程序进行评估也是如此。

在进行以下练习之前，您不妨刷新一下间奏1中介绍的有关功能的术语知识。大多数时候，代数课程掩盖了数学的这一方面，但是当您学习时，需要对术语进行精确的使用和理解。希望解决这些问题。

## 22 xml的商业

XML是一种广泛使用的数据语言。 一种用途涉及在不同计算机上运行的程序之间的消息交换。 例如，当您将Web浏览器指向某个网站时，就是将计算机上的程序连接到另一台计算机上的程序，而后者将XML数据发送到前者。 浏览器收到XML数据后，会将其作为图像呈现在计算机的监视器上。
本章介绍了处理XML的基础，XML是涉及交织的数据定义和迭代细化的另一种设计练习。 下一部分从对S表达式和XML数据的非正式比较开始，并使用它来形成完整的数据如果您认为XML对于2019年而言过于老式，请随时重做JSON或其他一些现代数据交换的练习 格式。 设计原理保持不变。 定义。 其余各节通过示例说明如何处理XML数据的S表达式。

## 22.1 XML as S-expressions

最基本的XML数据如下所示：

```html
<machine> </ machine>
```

它称为元素，“机器”是元素的名称。 元素的两个部分就像括号一样，界定了元素的内容。 如果除了空白以外的两个部分之间都没有内容，则XML可以简化表示：
<机器/>

但是，就我们在这里所关心的而言，该简写等同于明确括弧的版本。
从S表达式的角度来看，XML元素是一对命名的括号，包围着某些内容。Racket的xml库用结构和S表达式来表示XML。 实际上，用S表达式表示上面的内容是很自然的：

### 22.2 Rendering XML Enumerations

XML实际上是一族语言。 人们为特定的沟通渠道定义了方言。 例如，XHTML是用于以XML格式发送Web内容的语言。 在本节中，我们说明如何为一小段XHTML设计渲染功能，特别是从本章开始的枚举。

ul标签包含一个所谓的无序HTML列表。 此列表的每个项目都标记有li，li倾向于包含单词，但也包含其他元素，甚至是枚举。 使用“无序” HTML意味着每个项目都将使用前导项目符号而不是数字来呈现。

由于Xexpr没有附带纯字符串，因此如何在子集中表示XHTML枚举并不是立即显而易见的。 一种选择是再优化一次数据表示，以便Xexpr可以是String。 另一种选择是引入文本表示形式：

### 22.3 Domain-Specific Languages

工程师通常会构建大型软件系统，这些系统需要针对特定​​上下文进行配置，然后才能运行。此配置任务往往由必须处理许多不同软件系统的系统管理员来承担。 “配置”一词是指程序启动时主要功能需要的数据。从某种意义上说，配置只是一个附加参数，尽管它通常是如此复杂，以至于程序设计人员倾向于使用其他机制来进行传递。

由于软件工程师不能假设系统管理员会了解每种编程语言，因此他们倾向于设计简单的专用配置语言。这些特殊语言也称为领域特定语言（DSL）。由于配置将程序抽象到各种数据上，Paul Hudak在1990年代提出DSL是最终的抽象，即它们将抽象概念概括为完美。众所周知的XML语法表示，围绕通用核心开发这些DSL可以简化系统管理员的工作。他们可以编写小的XML“程序”，从而配置必须启动的系统。

虽然DSL的构建通常被认为是高级程序员的一项任务，但实际上您已经可以理解，欣赏和实现相当复杂的DSL。本节说明所有操作方式。它首先使您熟悉有限状态机（FSM）。然后说明如何设计，实现和编程DSL，以配置可模拟任意FSM的系统。

记住有限状态机有限状态机的主题是计算中的一个重要主题，本书对此进行了多次介绍。在这里，我们重用有限状态机中的示例作为我们希望为其设计和实现配置DSL的组件。


为了方便起见，图129再次显示了整个代码，尽管仅使用列表并使用了ISL +的全部功能来重新编写了代码。该程序由两个数据定义，一个数据示例和两个函数定义组成：模拟和查找。与前几章中的相关程序不同，此程序将过渡表示为两个项目的列表：当前状态和下一个。

主要功能（模拟）消耗转换表和初始状态。然后，它计算一个大爆炸表达式，该表达式对每个键事件进行状态转换。状态显示为彩色正方形。使用Lambda表达式指定to-draw和on-key子句，这些表达式消耗当前状态以及实际的键事件，并分别生成图像或下一个状态。

如其签名所示，辅助查找功能完全独立于FSM应用程序。它使用两个项目列表和一个项目的列表，但是这些项目的实际性质是通过参数指定的。在此程序的上下文中，X和Y表示FSM状态，这意味着find与状态一起消耗转换表并生成状态。函数体使用内置的assoc函数执行大部分工作。查找assoc的文档，以了解为什么本地正文使用if表达式。

### 22.4 Reading XML

系统管理员希望复杂的应用程序能够读取配置程序。本节使用2htdp / batch-io 2htdp / universe和2htdp /图像库。 从文件或可能从网络上的某个地方。 在ISL +中，您的程序可以检索（一些）XML信息。 图132显示了示教包的相关摘录。 为了保持一致，该图使用后缀.v3表示XML，包括没有版本2的那些数据定义：

## 23 同时处理

一些函数必须使用两个参数，它们属于具有非平凡数据定义的类。 如何设计此类函数取决于参数之间的关系。 首先，可能必须将其中一个论点视为原子论。 其次，函数可能必须在锁步中处理两个参数。 最后，该功能可以根据所有可能的情况处理给定的数据。 本章通过示例说明了这三种情况，并提供了扩展的设计方法。 最后一部分讨论复合数据的相等性。

### 23.1 Processing Two Lists Simultaneously: Case 1

### 23.7 Project: Database

## 24 总结

本书的第四部分是关于处理数据的功能设计，这些数据的描述需要许多相互关联的定义。这些数据形式显示在现实世界的任何地方，从计算机的本地文件系统到万维网以及动画电影中使用的几何形状。仔细阅读本书的这一部分后，您会知道设计秘诀也可以扩展到以下这些数据形式：
当程序数据的描述需要多个相互引用的数据定义时，设计方案就要求同时开发模板，每个数据定义一个。如果数据定义A引用数据定义B，则模板A函数完全相同的位置和方式指B函数。否则，设计配方将像以前一样起作用，发挥作用。

当一个函数必须处理两种类型的复杂数据时，您需要区分三种情况。首先，函数可以像处理原子一样处理其中一个参数。第二，这两个参数应该具有完全相同的结构，并且该函数以完全并行的方式遍历它们。第三，该功能可能必须分别处理所有可能的组合。在这种情况下，您将创建一个二维表，该表沿一维枚举一种数据定义中的所有数据，而沿另一维处理第二种数据。最后，您可以使用表格的单元格来制定各种情况的条件和答案。

本书的这一部分涉及两个复杂参数的函数。如果遇到一种罕见的情况，其中函数会接收三个复杂的数据，那么您就会知道（需要）一个三维表。

现在，您已经看到了在职业生涯中可能会遇到的所有形式的结构数据，尽管细节会有所不同。如果遇到困难，请记住设计秘诀；它会让您入门。
