# 纠缠在一起的数据

您可能会认为列表和自然数的数据定义非常不寻常。这些数据定义是自指的，很可能是您遇到的第一个此类定义。事实证明，许多数据类别都需要比这两种更为复杂的数据定义。通用概括涉及在一个数据定义或一堆互相引用的数据定义中的许多自引用。这些数据形式已经无处不在，因此对于程序员来说，学会应对任何数据定义集合都是至关重要的。这就是设计诀窍的全部内容。

这一部分从设计秘诀的一般化开始，以便它适用于所有形式的结构数据定义。接下来，它从“项目”中引入迭代细化的概念：严格列出列表，因为复杂的数据定义不是一口气就能开发出来的，而是分几个阶段来开发的。确实，使用迭代改进是所有程序员都不是科学家的原因之一，也是我们的学科在其美国名称中使用“科学”一词的原因之一。最后两章说明了这些想法：一章介绍了如何为BSL设计解释器，另一章介绍了如何处理XML（一种Web数据交换语言）。上一章再次扩展了设计秘诀，将其重新设计用于可同时处理两个复杂参数的函数。

## 19 s表达式的诗歌

编程类似于诗歌。 像诗人一样，程序员在看似毫无意义的想法上练习技巧。 如上一章所述，它们一直在进行修改和编辑。 本章介绍了越来越复杂的数据形式-似乎没有现实目的。 即使我们提供了动机背景，所选择的数据类型也非常纯净，您再也不会遇到它们。

但是，本章将展示设计方法的全部功能，并向您介绍实际程序所能处理的各种数据。 为了将这些资料与您在程序员生活中会遇到的东西联系起来，我们用适当的名称标记每个部分：树，森林，XML。 最后一个有点误导，因为它实际上与S表达式有关。 S表达式和XML之间的联系在《项目：XML的商业》中得到了阐明，与本章相反，它与现实世界中对复杂数据形式的使用更加接近。

### 19.1 树

我们所有人都有一棵家谱。 绘制家谱的一种方法是，每当孩子出生时添加一个元素，并连接父母的元素。 对于那些父母不认识的人来说，没有绘画的联系。 结果就是祖先家谱，因为该树指向任何人，都指向该人的所有已知祖先。

没有尽头。 为了避免这种无意义的数据定义，我们要求自引用数据定义包含多个子句，并且其中至少有一个不引用该数据定义。
让我们暂时推迟一下数据定义，然后尝试一下。 假设我们要将一个孩子添加到现有的家谱中，并且已经有父母的表示形式。 在这种情况下，我们可以简单地构造一个新的子结构。 例如，要在已经代表Carl和Bettina的程序中代表Adam，只需添加以下子结构即可：

我们的实验提出了两种见解。 首先，我们不是在寻找描述如何生成子结构实例的数据定义，而是在寻找描述如何表示家族树的数据定义。 其次，数据定义由两个子句组成，一个子句用于描述未知家族树的变量，另一个子句用于已知家族树：

首先，我们不着眼于在家谱上设计具体的功能，而是查看此类功能的一般组织。 也就是说，在不考虑具体任务的情况下，让我们尽可能多地研究设计诀窍。 我们从标题材料开始，即配方的第2步：

现在我们准备定义实际功能。该函数区分两种情况：无父母和有子女。对于第一种情况，即使我们没有提供任何示例，答案也应该显而易见。由于给定的家谱不包含任何子级，因此不能包含以“蓝色”作为眼睛颜色的子级。因此，第一个cond子句中的结果为#false。

对于第二个cond子句，设计需要做很多工作。再次遵循设计秘诀，我们首先提醒自己模板中的表达式完成了什么：
根据功能的目的说明，
（蓝眼睛的孩子？（儿童父亲antree）

确定父亲的FT中的某个孩子是否有“蓝眼睛”；
同样，（蓝眼睛的孩子？（儿童母亲的后代））确定母亲FT中的某人是否有蓝眼睛；和

选择器表达式（child-name an-ftree），（child-date an-ftree）和（child-eyes an-ftree）分别从给定的子结构中提取名称，出生日期和眼睛颜色。

现在我们只需要弄清楚如何组合这些表达式。
显然，如果子结构在“眼睛”字段中包含“蓝色”，则该函数的答案为#true。接下来，关于名称和出生日期的表达式是无用的，这使我们有了递归调用。如前所述，（蓝眼睛的孩子？（孩子-父亲an-ftree））穿过父亲一侧的树，而家谱的母亲一侧则经过处理（“蓝眼睛的孩子？（孩子-母亲和孩子）”）。 -ftree））。如果这些表达式中的任何一个返回#true，则an-ftree包含一个眼睛为“蓝”的孩子。

### 19.2 Forests

It is a short step from a family tree to a family forest:

```racket
; An FF (short for family forest) is one of: 
; – '()
; – (cons FT FF)
; interpretation a family forest represents several
; families (say, a town) and their ancestor trees
```

**问题示例**设计函数“森林中的蓝眼睛的孩子”？该函数确定家庭森林中是否包含在视场中带有“蓝色”的孩子。

简单的解决方案如图115所示。您可以自己研究签名，目的陈述和示例。我们专注于计划组织。关于模板，设计可以使用列表模板，因为该功能会消耗列表。如果列表中的每个项目都是带有眼睛区域的结构，则该函数将使用针对眼睛区域的选择器功能和字符串比较在这些结构上进行迭代。在这种情况下，每个项目都是一棵家谱，但是幸运的是，我们已经知道如何处理家谱。

让我们退后一步，看看我们如何解释图115。起点是一对数据定义，其中第二个引用第一个，两个都引用自己。结果是一对函数，其中第二个引用第一个，两个都引用自己。换句话说，函数定义相互引用的方式与数据定义相互引用的方式相同。前面的章节掩盖了这种关系，但是现在情况非常复杂，值得关注。

### 19.3 S-expressions

; An S-expr is one of: 
; – Atom
; – SL
 
; An SL is one of: 
; – '()
; – (cons S-expr SL)

; An Atom is one of: 
; – Number
; – String
; – Symbol 

S表达式的概念归因于John McCarthy和他的Lispers，他们于1958年创建了S表达式，以便他们可以与其他Lisp程序一起处理Lisp程序。 这种看似循环的推理听起来似乎有些深奥，但正如Intermezzo 2：Quote，Unquote中所提到的那样，S表达式是一种通用的数据形式，经常会被重新发现，最近一次是在万维网上的应用。 因此，使用S表达式可为如何为高度相互关联的数据定义设计函数的讨论做准备。

到这本书为止，没有数据需要像S表达式那样复杂的数据定义。 然而，有一个额外的提示，如果您遵循设计秘诀，则可以设计处理S表达式的函数。 为了说明这一点，让我们来看一个具体的例子：
样本问题设计函数计数，该函数计数确定某些符号在某些S表达式中出现多少次。

尽管第一步要求进行数据定义并且似乎已经完成，但是请记住，它还要求创建数据示例，尤其是在定义复杂时。

### 19.5 Project: BSTs

程序员通常使用数据的树表示形式来改善其功能的性能。 树的一种特别著名的形式是二进制搜索树，因为它是快速存储和检索信息的好方法。

(define-struct no-info [])
(define NONE (make-no-info))
 
(define-struct node [ssn name left right])
; A BT (short for BinaryTree) is one of:
; – NONE
; – (make-node Number Symbol BT BT)

换句话说，要检查BT是否也属于BST，我们必须检查所有子树中的所有数字，并确保它们小于或大于给定的数字。 这给数据的构建带来了额外的负担，但是，如以下练习所示，这是非常值得的。

在BST中寻找具有给定ssn的节点可能会利用BST不变性。 为了找出BT是否包含具有特定ssn的节点，功能可能必须查看树的每个节点。 相反，为了找出二叉搜索树是否包含相同的ssn，函数可以针对其检查的每个节点消除两个子树之一。

让我们用这个示例BST来说明这个想法：
（make节点66'a L R）

如果我们正在寻找66，我们已经找到了我们正在寻找的节点。 现在，如果我们要查找较小的数字（例如63），则可以将搜索集中在L上，因为ssn字段小于66的所有节点都在L中。类似地，如果要查找99，我们将忽略L并关注 在R上是因为ssns大于66的所有节点都在R中。

### 19.6 Simplifying Functions

## 20 迭代细化

在开发实际程序时，您可能会遇到复杂的信息形式以及用数据表示它们的问题。解决此任务的最佳策略是使用迭代优化，这是众所周知的科学过程。科学家的问题是要使用某种形式的数学来代表现实世界的一部分。努力的结果称为模型。然后，科学家以多种方式测试模型，特别是通过预测实验结果。如果预测和测量之间的差异太大，则以改善预测为目标来完善模型。该迭代过程将继续进行，直到预测足够准确为止。

考虑一个希望预测火箭飞行路线的物理学家。尽管“火箭作为一个点”表示很简单，但它也很不准确，例如无法考虑空气摩擦。作为响应，物理学家可以添加火箭的大致轮廓，并引入必要的数学来表示摩擦。第二个模型是第一个模型的改进。一般而言，科学家会重复进行此过程（或按照程序员的说法进行迭代），直到模型以足够的精度预测火箭的飞行路径为止。

在计算机科学系受过训练的程序员应像这位物理学家一样继续前进。关键是找到真实信息和正确处理它们的功能的准确数据表示形式。复杂的情况要求完善过程以结合适当的功能获得足够的数据表示。该过程从基本信息开始，然后根据需要添加其他信息。有时，由于用户要求其他功能，因此程序员必须在部署程序后优化模型。

到目前为止，在涉及复杂数据形式时，我们已经为您使用了迭代优化。本章通过扩展示例说明迭代优化，将其作为程序开发的原理，以表示和处理（部分）计算机文件系统。我们从对文件系统的简短讨论开始，然后迭代开发三种数据表示形式。在此过程中，我们提出了一些编程练习，以便您了解设计秘诀还如何帮助修改现有程序。

### 20.1 Data Analysis

在大多数计算机系统上，文件组织在目录或文件夹中。 粗略地说，目录包含一些文件和更多目录。 后者称为子目录，可能包含更多子目录和文件。 由于层次结构，我们谈到目录树。

图123包含一棵小目录树的图形草图，该图说明了为什么计算机科学家将其称为树。 与计算机科学中的惯例相反，该图显示了该树向上生长，并带有一个名为TS的根目录。 根目录包含一个名为read！的文件，以及两个分别称为Text和Libs的子目录。 第一个子目录Text仅包含三个文件。 后者Libs仅包含两个子目录，每个子目录至少包含一个文件。 最后，每个框都有两个注释之一：目录用DIR注释，文件用数字（大小）数字注释。

### 20.2 Refining Data Definitions

## 21 细化解释器

DrRacket是一个程序。这是一个复杂的数据，处理许多不同种类的数据。像大多数复杂的程序一样，DrRacket也包含许多功能：一个允许程序员编辑文本的功能，另一个像交互区域一样工作的功能，第三个用于检查定义和表达式是否“语法”的功能等等。

在本章中，我们将向您展示如何设计实现交互区域核心的功能。自然地，我们对该设计项目使用迭代优化。实际上，专注于DrRacket的这一方面的想法是另一种改进的实例，即，仅实现一项功能的显而易见的想法。

简而言之，交互区域执行确定输入的表达式值的任务。单击“运行”后，交互区域将了解所有定义。然后可以接受可能引用这些定义的表达式，确定该表达式的值，并根据需要多次重复此循环。因此，许多人也将交互区域称为read-eval-print循环，其中eval表示评估程序，该功能也称为解释程序。

像本书一样，我们的优化过程从数字BSL表达式开始。它们很简单；他们不承担对定义的理解；甚至您五年级的妹妹都可以确定他们的价值。理解了第一步之后，您就知道了BSL表达式及其表示形式之间的区别。接下来，我们进入带有变量的表达式。最后一步是添加定义。

### 21.1 Interpreting Expressions

我们的首要任务是就BSL程序的数据表示形式达成共识。 也就是说，我们必须弄清楚如何将BSL表达式表示为一条BSL数据。 起初，这听起来很奇怪和不同寻常，但这并不困难。 假设我们只想表示一个数字，加法和乘法。 显然，数字可以代表数字。 但是，加法表达式需要复合数据，因为它包含两个表达式并且因为它不同于乘法表达式，乘法表达式也需要数据表示。

### 21.2 Interpreting Variables

### 21.3 Interpreting Functions

至此，您了解了如何评估由常量定义和变量表达式组成的BSL程序。自然地，您希望添加函数定义，以便至少在原理上知道如何处理所有BSL。

本部分的目的是优化解释变量的评估程序，使其可以处理函数。由于函数定义显示在定义区域中，因此描述改进的求值器的另一种方法是，当定义区域包含许多函数定义并且程序员在包含这些函数用途的交互区域中输入表达式时，它可以模拟DrRacket。 。

为简单起见，我们假设定义区域中的所有函数都使用一个参数，并且只有一个这样的定义。必要的领域知识可以追溯到学校，在这里您了解到f（x）= e表示函数f的定义，f（a）表示f在a上的应用，并且要评估后者，您可以用a代替x在e。事实证明，使用诸如BSL之类的语言对功能应用程序进行评估也是如此。

在进行以下练习之前，您不妨刷新一下间奏1中介绍的有关功能的术语知识。大多数时候，代数课程掩盖了数学的这一方面，但是当您学习时，需要对术语进行精确的使用和理解。希望解决这些问题。

## 22 xml的商业

## 23 同时处理

## 24 总结

