# 第二章 任意大的数据

固定大小数据中的每个数据定义都描述固定大小的数据。对我们来说，布尔值，数字，字符串和图像是原子的；计算机科学家说，它们的大小只有一个单位。通过结构，您可以组成固定数量的数据。即使您使用数据定义的语言来创建深度嵌套的结构，您也始终会知道任何特定实例中原子数据的确切数量。但是，许多编程问题都处理了不确定的信息量，这些信息必须作为一条数据处理。例如，一个程序可能必须计算一堆数字的平均值，而另一个程序可能必须跟踪交互式游戏中任意数量的对象。无论如何，根据您的知识，不可能制定一个可以将这种信息表示为数据的数据定义。

本部分修改了数据定义的语言，以便可以描述（有限但任意）大小的数据。为了具体说明，本部分的前半部分处理列表，这是一种数据形式，出现在大多数现代编程语言中。与数据定义的扩展语言并行，此部分还修改了设计配方以应对此类数据定义。后几章说明了这些数据定义和修订的设计方案如何在各种情况下工作。

## 8 列表

您可能以前从未遇到过自引用定义。 您的英语老师肯定会远离这些知识，而关于这些定义，许多数学课程都含糊不清。 程序员不能含糊其词。 他们的工作需要精确。 虽然一个定义通常可以包含多个对其自身的引用，但本章介绍了仅需一个的有用示例，从列表的一个开始。

列表的引入还充实了我们可以研究的应用程序种类。 虽然本章将通过示例精心构建您的直觉，但也会在下一章中激发设计秘诀的修订，该章解释了如何系统地创建处理自引用数据定义的功能。

### 8.1 创建列表

我们所有人一直在列出清单。 在去杂货店购物之前，我们会写下我们要购买的物品清单。 有些人每天早晨写下待办事项清单。 在十二月期间，许多孩子准备了圣诞节愿望清单。 要计划一个聚会，我们列出了被邀请者的名单。 以列表的形式排列信息是我们生活中无处不在的一部分。

鉴于信息以列表的形式出现，我们必须清楚地学习如何将此类列表表示为BSL数据。 确实，由于列表是如此重要，所以BSL带有对创建和处理列表的内置支持，类似于对笛卡尔点（posn）的支持。 与点相反，列表的数据定义始终留给您。 但是首先是第一件事。 我们从创建列表开始。

当我们形成一个列表时，我们总是从空列表开始。 在BSL中，我们用

```racket
'()
(cons "Mercury" '())
(cons "Venus"
    (cons "Mercury"
        '()))
```

图44的最后一行说明了具有三个项目的列表。 它的其余字段包含一个框，该框又包含一个框。 因此，在创建列表时，我们将盒子放入盒子中，依此类推。 乍一看，这似乎很奇怪，但就像我们有时会在生日那天得到的一组中国礼品盒或一组嵌套的水杯一样。 唯一的区别是BSL程序可以嵌套列表的深度比任何艺术家可以嵌套物理框的深度都要深。
由于即使是优秀的美术师，在绘制深层嵌套的结构时也会遇到问题，因此计算机科学家会转而使用方框图和箭头图。 图45说明了如何重新排列图44的最后一行。每个缺点结构变成一个单独的框。 如果其余字段太复杂而无法在框内绘制，我们将改为绘制一个项目符号，并在其中包含一条带有箭头的线。 根据框的排列方式，您会得到两种图表。 第一个显示在图45的第一行中，按创建顺序列出了这些框。 第二行显示在底行中，按排列顺序将它们列出。 因此，第二张图立即告诉您，无论列表有多长，应用到列表中时，第一个将产生什么。 因此，程序员更喜欢第二种安排。

当然，此数据定义使用cons就像其他使用构造实例的构造函数一样，从某种意义上说，cons只是一个特殊的构造函数。 该数据定义无法说明的是如何形成任意长度的列表：不包含任何内容，一个项目，两个项目，十个项目或可能包含1,438,901项的列表。

```racket
; A List-of-names is one of:
; – '()
; – (cons String List-of-names)
; interpretation a list of invitees, by last name
```

深吸一口气，再读一遍。 此数据定义是您遇到过的最不寻常的定义之一-您从未见过引用其自身的定义。 甚至还不清楚是否有意义。 毕竟，如果您告诉英语老师“桌子就是桌子”定义了“桌子”一词，则最有可能的回答就是“胡说八道！”，因为自我指称的定义无法解释单词的含义。
但是，在计算机科学和程序设计中，自引用定义起着核心作用，并且在某些情况下，这样的定义确实很有意义。 这里的“有意义”意味着我们可以将数据定义用于预期的用途，即生成属于正在定义的类的数据示例或检查某些给定的数据是否属于已定义的类。 数据的。 从这个角度来看，名称列表的定义是完全有意义的。 至少，我们可以使用逐项说明中的第一个子句生成'()作为示例。 给定'()作为名称列表的元素，可以很容易地创建第二个：

### 8.2 '()是什么， cons是什么

让我们退后一会儿，仔细看看'()和cons。 如前所述，'()只是一个常数。 与常量5或“这是一个字符串”进行比较时，它看起来更像是函数名或变量； 但是与#true和#false进行比较时，应该很容易看出它实际上只是BSL对空列表的表示。

至于我们的评估规则，'()是一种新型的原子值，与任何其他类型的原子值不同：数字，布尔值，字符串等。 它也不是复合值，例如Posns。 确实，'()非常独特，它本身就属于一类值。 因此，此类值附带一个谓词，该谓词仅识别'()，而不能识别其他任何内容：

略去一堆代码实例

关键的见解是'()是一个唯一值，而cons是一个生成列表值的已检查构造函数。 此外，first，rest和cons吗？ 只是普通谓词和选择器的唯一名称。 因此，本章所教的不是创建数据的新方法，而是制定数据定义的新方法。

### 8.3 列表相关的操作

**Sample Problem** You are working on the contact list for some new cell phone. The phone’s owner updates and consults this list on various occasions. For now, you are assigned the task of designing a function that consumes this list of contacts and determines whether it contains the name “Flatt.”

**示例问题**您正在处理某些新手机的联系人列表。 手机的所有者会在各种情况下更新并查询此列表。 目前，您已分配了设计一个功能的任务，该功能使用此联系人列表并确定其是否包含名称“ Flatt”。

喘口气。 运行程序。 标头是函数的“虚拟”定义； 你有一些例子； 他们已经变成测试； 最重要的是，其中一些实际上成功了。 他们因错误的原因而成功，但成功了。 如果现在一切正常，请继续阅读。
第四步是设计一个与数据定义匹配的功能模板。 由于字符串列表的数据定义包含两个子句，因此函数的主体必须是带有两个子句的cond表达式。 这两个条件确定了要接收的函数是两种列表中的哪一种：

```racket
; A ConsOrEmpty is one of: 
; – '()
; – (make-pair Any ConsOrEmpty)
; interpretation ConsOrEmpty is the class of all lists

; List-of-name -> Boolean
; determines whether "Flatt" is on a-list-of-names
;(define (contains-flatt? a-list-of-names)
;  #false)

(check-expect (contains-flatt? '()) #false)
(check-expect (contains-flatt? (cons "Find" '()))
                               #false)
(check-expect (contains-flatt? (cons "Flatt" '()))
                               #true)  

(check-expect
  (contains-flatt?
    (cons "A" (cons "Flatt" (cons "C" '()))))
  #true)

(define (contains-flatt? alon)
  (cond
    [(empty? alon) #false]
    [(cons? alon)
     (or (string=? (first alon) "Flatt")
         (contains-flatt? (rest alon)))]))
```

然后，图47显示了完整的定义。 总体而言，它与本书第一章中的定义并没有太大不同。 它由一个签名，一个目的陈述，两个示例和一个定义组成。 此函数定义与您之前所见的唯一不同之处是自引用，即对contains-flatt的引用？ 在定义的主体中。 再说一次，数据定义也是自引用的，因此从某种意义上说，函数中的自引用应该不会太令人惊讶。

### 8.4 列表相关计算

图48显示了第一步，该步骤使用通常的替换规则来确定应用程序的值。 结果是一个条件表达式，因为正如代数老师会说的那样，该函数是以逐步方式定义的。

详细解释函数的运行过程。

## 9 自引用数据定义的设计

乍一看，自引用数据定义似乎比混合数据的定义复杂得多。 但是，以包含扁平化为例？ 如图所示，设计方案的六个步骤仍然有效。 不过，在本节中，我们将设计秘诀概括化，以使其更适合于自引用数据定义。 新部分涉及以下过程：发现何时需要自引用数据定义，派生模板并定义函数主体：

1. 如果问题说明涉及任意大小的信息，则需要一个自引用数据定义来表示它。 在这一点上，您只看到了一个这样的类，即名称列表。 图51的左侧显示了如何以相同方式定义字符串列表。 其他原子数据列表的工作方式相同。

为了使自引用数据定义有效，它必须满足两个条件。首先，它必须至少包含两个子句。其次，这些子句中的至少一个不得回溯到正在定义的数据类别。优良作法是使用箭头从数据定义中的引用回到要定义的术语来明确标识自引用。有关此类注释的示例，请参见图51。

您必须通过创建数据示例来检查自引用数据定义的有效性。从不引用数据定义的子句开始；继续使用第一个示例，其中子句引用定义本身。对于图51中的数据定义，您将因此获得类似于以下三个列表：
'()             by the first clause
(cons "a" '())  by the second clause, previous example
(cons "b"
  (cons "a"
    '()))

如果无法根据数据定义生成示例，则该示例无效。如果您可以生成示例，但是看不到如何生成更大的示例，则该定义可能不符合其解释。

2. 标题材料没有任何变化：签名，目的陈述和虚拟定义。 当您制定用途声明时，请专注于函数的计算方式而不是它的处理方式，尤其不要关注函数如何通过给定数据的实例。

3. 对于函数示例，请确保遍历多次使用数据定义的自引用子句的输入。 这是制定涵盖以后整个函数定义的测试的最佳方法。

4. 在核心，自引用数据定义看起来像是混合数据的数据定义。 因此，可以根据分项和结构中的配方进行模板的开发。 具体来说，我们用一个cond子句来构造一个cond表达式，该cond子句与数据定义中的子句一样多，将每个识别条件与数据定义中的相应子句进行匹配，并在处理复合值的所有cond行中写下适当的选择器表达式。我们将函数的自用称为递归，而在本书的前四部分中将其称为自然递归。

5. 对于函数体，我们从那些没有递归函数调用的条件线开始，这被称为基本案例。相应的答案通常很容易制定或已经作为示例给出。
然后我们处理自指案例。 我们首先提醒自己，模板行中的每个表达式计算什么。 对于自然递归，我们假设该函数已经按照我们的目标声明中指定的方式工作了。 最后一步是信念的飞跃，但是正如您将看到的，它始终有效。   为了使我们的读者感到好奇，任意大数据的设计方法都对应于数学中的所谓“归纳证明”，而“信仰的飞跃”则代表将归纳假设用于此类证明的归纳步骤。 逻辑通过归纳定理证明了该证明技术的有效性。

6. 最后，确保将所有示例转换为测试，这些测试通过，并且运行它们涵盖了函数的所有部分。

### 9.1 练习

### 9.2 非空列表








