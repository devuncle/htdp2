# Generative Recursion 生成递归

如果遵循前四部分的设计方法，要么将领域知识转化为代码，要么利用数据定义的结构来组织代码。我们将那些与“结构”组进行分组。后者函数通常将其参数分解为它们的直接结构组件，然后处理这些组件。如果这些直接组件之一与输入属于同一类数据，则该函数在结构上是递归的。尽管结构设计的功能构成了世界上绝大多数代码，但是使用结构化的设计方法无法解决某些问题。

为了解决这些复杂的问题，程序员使用生成式递归，这种形式的递归比结构递归更强大。生成递归的研究与数学一样古老，通常被称为算法研究。算法的输入表示一个问题。一种算法倾向于将一个问题重新排列为一系列问题，加以解决，然后将其解决方案组合为一个整体解决方案。通常，这些新生成的问题中的一些问题与给定的问题相同，在这种情况下，可以重用该算法来解决它们。在这些情况下，该算法是递归的，但是其递归使用新生成的数据而不是输入数据的直接部分。

从生成递归的描述中可以看出，设计生成递归函数比设计结构递归函数更特别。尽管如此，通用设计秘诀的许多元素也适用于算法设计，而本书的这一部分说明了设计秘诀的方式和作用。设计算法的关键是“生成”步骤，这通常意味着划分问题。找出一种解决问题的新颖方法需要洞察力。在希腊语中，这是“尤里卡！”，有时几乎不需要洞察力。例如，它可能只需要一些有关分解字母序列的常识。在其他时候，它可能依赖于关于数字的深层数学定理。实际上，程序员自己设计简单的算法，并依靠领域专家来解决复杂的问题。无论哪种方式，程序员都必须彻底理解其基本思想，以便他们可以编写算法并让程序与未来的读者交流。熟悉该想法的最佳方法是研究大量示例，并对可能在现实世界中出现的各种生成递归产生一种感觉。

## 25 Non-standard Recursion

至此，您已经设计了许多使用结构递归的函数。 设计功能时，您知道需要查看其主要输入的数据定义。 如果此输入是通过自引用数据定义描述的，则最终会得到一个函数，该函数基本上引用自身，而数据定义引用自身。

本章介绍了两个不同使用递归的示例程序。 它们说明了需要一些“尤里卡”的问题，从明显的想法到复杂的见识。

### 25.1 Recursion without Structure

假设您已加入DrRacket团队。 该团队正在开发一种共享服务，以支持程序员之间的协作。 具体而言，DrRacket的下一个修订版将使ISL程序员能够在多台计算机上共享其DrRacket定义区域的内容。 每次一个程序员修改缓冲区时，修改后的DrRacket都会向参与共享会话的DrRacket实例广播定义区域的内容。

**示例问题**您的任务是设计函数名字为bundle，该函数准备广播的定义区域的内容。 DrRacket将内容作为1String列表移交。 该函数的任务是将各个“字母”的块捆绑成块，从而生成给定长度（称为块大小）的字符串（称为块）列表。
