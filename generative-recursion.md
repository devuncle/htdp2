# Generative Recursion 生成递归

如果遵循前四部分的设计方法，要么将领域知识转化为代码，要么利用数据定义的结构来组织代码。我们将那些与“结构”组进行分组。后者函数通常将其参数分解为它们的直接结构组件，然后处理这些组件。如果这些直接组件之一与输入属于同一类数据，则该函数在结构上是递归的。尽管结构设计的功能构成了世界上绝大多数代码，但是使用结构化的设计方法无法解决某些问题。

为了解决这些复杂的问题，程序员使用生成式递归，这种形式的递归比结构递归更强大。生成递归的研究与数学一样古老，通常被称为算法研究。算法的输入表示一个问题。一种算法倾向于将一个问题重新排列为一系列问题，加以解决，然后将其解决方案组合为一个整体解决方案。通常，这些新生成的问题中的一些问题与给定的问题相同，在这种情况下，可以重用该算法来解决它们。在这些情况下，该算法是递归的，但是其递归使用新生成的数据而不是输入数据的直接部分。

从生成递归的描述中可以看出，设计生成递归函数比设计结构递归函数更特别。尽管如此，通用设计秘诀的许多元素也适用于算法设计，而本书的这一部分说明了设计秘诀的方式和作用。设计算法的关键是“生成”步骤，这通常意味着划分问题。找出一种解决问题的新颖方法需要洞察力。在希腊语中，这是“尤里卡！”，有时几乎不需要洞察力。例如，它可能只需要一些有关分解字母序列的常识。在其他时候，它可能依赖于关于数字的深层数学定理。实际上，程序员自己设计简单的算法，并依靠领域专家来解决复杂的问题。无论哪种方式，程序员都必须彻底理解其基本思想，以便他们可以编写算法并让程序与未来的读者交流。熟悉该想法的最佳方法是研究大量示例，并对可能在现实世界中出现的各种生成递归产生一种感觉。

## 25 Non-standard Recursion

至此，您已经设计了许多使用结构递归的函数。 设计功能时，您知道需要查看其主要输入的数据定义。 如果此输入是通过自引用数据定义描述的，则最终会得到一个函数，该函数基本上引用自身，而数据定义引用自身。

本章介绍了两个不同使用递归的示例程序。 它们说明了需要一些“尤里卡”的问题，从明显的想法到复杂的见识。

### 25.1 Recursion without Structure

假设您已加入DrRacket团队。 该团队正在开发一种共享服务，以支持程序员之间的协作。 具体而言，DrRacket的下一个修订版将使ISL程序员能够在多台计算机上共享其DrRacket定义区域的内容。 每次一个程序员修改缓冲区时，修改后的DrRacket都会向参与共享会话的DrRacket实例广播定义区域的内容。

**示例问题**您的任务是设计函数名字为bundle，该函数准备广播的定义区域的内容。 DrRacket将内容作为1String列表移交。 该函数的任务是将各个“字母”的块捆绑成块，从而生成给定长度（称为块大小）的字符串（称为块）列表。

## 26 设计算法

本部分的概述已经说明，生成递归函数的设计比结构设计更特别。 如第一章所示，两个生成的递归在处理函数的方式上可能根本不同。 bundle和quicksort <进程列表都可以，但是前者至少尊重给定列表中的顺序，而后者则可以随意重新排列其给定列表。 问题是，单个设计方案是否可以帮助创建如此广泛不同的功能。

第一部分说明如何使设计配方的过程尺寸适应生成递归。 第二部分介绍了另一个新现象：一种算法可能无法为其某些输入提供答案。 因此，程序员必须分析他们的程序，并在注释中补充有关终止的信息。 其余部分对比结构递归和生成递归。

### 26.1 Adapting the Design Recipe

### 26.2 Termination 终止

### 26.3 Structural versus Generative Recursion

现在，您可能想知道结构递归设计和生成递归设计之间是否存在真正的区别。 我们的答案是“取决于”。当然，我们可以说使用结构递归的所有功能只是生成递归的特殊情况。 但是，如果我们希望了解功能设计的过程，那么这种“一切都平等”的态度无济于事。 它混淆了两种需要不同形式的知识并产生不同结果的设计。 一个依赖于系统的数据分析，仅此而已； 另一个则需要对问题解决过程本身有深刻的，通常是数学的洞察力。 一个导致程序员自然终止函数；另一个使程序员自然终止函数。 另一个需要终止参数。 混淆这两种方法是无济于事的。

### 26.4 Making Choices

您现在可能会认为生成递归设计已经发现了gcd问题的更快解决方案，并且您可能会得出结论，生成递归始终是正确的选择。这种判断太轻率了，原因有三点。首先，即使设计良好的算法也不一定总是比等效的结构递归函数快。例如，quick-sort <仅在大型列表中获胜；对于小型打印机，标准sort <函数更快。更糟糕的是，设计不当的算法会严重破坏程序的性能。其次，使用结构递归的配方来设计功能通常比较容易。相反，设计算法需要构思如何产生新问题，这一步骤通常需要一些深刻的见识。最后，即使没有太多文档，阅读函数的程序员也可以轻松理解结构递归函数。但是，算法的生成步骤基于“ eureka！”，并且如果没有很好的解释，将来的读者将很难理解，其中包括您的较早版本。

经验表明，程序中的大多数功能都采用结构设计。只有少数利用生成递归。当我们遇到设计可以使用配方进行结构或生成递归的情况时，最好的方法是从结构版本开始。如果结果对于手头的任务来说太慢了-仅在那时如此-现在该探讨生成递归的用法了。

## 27 Variations on the Theme

算法的设计始于对如何创建一个比给定问题更容易解决的问题的过程的非正式描述，该问题的解决方案有助于解决给定问题。 提出这种想法需要启发，沉浸在应用程序领域中，并需要许多不同种类的示例的经验。

本章介绍了算法的几个示例。 有些是直接从数学中提取的，而数学是许多思想的源头。 其他来自计算设置。 第一个示例是我们原理的图形说明：Sierpinski三角形。 第二篇以找到函数根的简单数学示例说明了分治法则。 然后，它展示了如何将这种想法变成一种广泛使用的，用于搜索序列的快速算法。 第三部分涉及“解析” 1String的序列，这也是现实编程中的常见问题。

## 28 Mathematical Examples

数学问题的许多解决方案都采用生成递归。 未来的程序员必须了解此类解决方案，原因有两个。 一方面，大量的编程任务实质上是将这些数学思想转变为程序。 另一方面，练习此类数学问题通常证明对算法设计具有启发性。 本章处理三个此类问题。

## 29 Algorithms that Backtrack

解决问题的步伐并不总是那么顺畅。 有时，我们可能会采用一种方法，发现我们因为走错了路而陷入困境。 一个明显的选择是回溯到我们做出决定的地方并采取不同的态度。 有些算法就是这样工作的。 本章介绍两个实例。 第一部分介绍了遍历图形的算法。 第二个是扩展的练习，在象棋拼图的上下文中使用回溯。

## 30 小结

本书的第五部分介绍了尤里卡的想法！进入程序设计。与前四个部分的结构设计不同，尤里卡！设计从程序应该如何解决问题或处理代表问题的数据的想法开始。在这里进行设计意味着针对新的问题提出一种聪明的方法来调用递归函数，该新问题类似于给定的问题，但更为简单。

请记住，尽管我们将其称为生成递归，但大多数计算机科学家都将这些功能称为算法。

完成本书的这一部分后，您将了解有关生成递归设计的以下内容：
设计配方的标准轮廓仍然有效。

主要变化涉及编码步骤。它介绍了四个新问题，即从用于生成递归的完全通用模板到完整的功能。有了其中两个问题，您便可以得出解决方案过程中的“琐碎”部分；然后与其他两个一起制定生成解决方案的步骤。

较小的变化是关于生成递归函数的终止行为。与结构设计的功能不同，某些输入的算法可能不会终止。此问题可能是由于构思的固有限制或将构思转换为代码所致。无论如何，您的程序的未来读者都应该对潜在的“不良”输入提出警告。

您将在现实世界中的编程任务中遇到一些简单或众所周知的算法，并且有望应付。对于真正聪明的算法，软件公司聘请高薪的专家，领域专家和数学家来计算概念细节，然后再要求程序员将这些概念转化为程序。您还必须为这种任务做好准备，最好的准备就是练习。
