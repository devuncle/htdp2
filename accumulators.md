# Accumulators

当您要求ISL +将某些函数f应用于参数a时，通常会得到一些值v。如果再次求值（f a），则会再次得到v。事实上，无论您请求（f a）的评估频率如何，都将得到v。函数应用程序也可能永远循环或发出错误信号，但我们忽略了这些可能性。我们也忽略了随机性，这是该规则的真正例外。该功能是首次应用还是第100次应用，无论应用程序位于DrRacket的交互区域还是功能本身内部，都没有关系。该功能根据其用途说明运行，这就是您所需要知道的。

上下文无关的原理在递归函数的设计中起着至关重要的作用。在设计时，您可以自由地假设该函数计算了用途声明所承诺的内容，即使该函数尚未定义。特别是，您通常可以在其cond子句之一中自由使用递归调用的结果来创建某些函数的代码。结构和生成递归函数的设计配方的模板和编码步骤都依赖于此思想。

尽管上下文无关性促进了功能的设计，但它引起了两个问题。通常，上下文无关会导致递归评估中知识的丢失；函数不会“知道”是在完整列表中还是在该列表的一部分上调用了它。对于结构递归程序，这种知识的丢失意味着它们可能不得不多次遍历数据，从而导致性能损失。对于使用生成递归的函数，丢失意味着该函数可能根本无法计算结果。上一部分使用图遍历函数说明了第二个问题，该遍历函数无法为圆形图找到两个节点之间的路径。

本部分介绍了设计方案的变体，以解决此“上下文丢失”问题。由于我们希望保留（f a）无论返回的频率如何或在何处都返回相同结果的原理，因此唯一的解决方案是添加一个表示函数调用上下文的参数。我们将此附加参数称为累加器。在数据遍历期间，递归调用继续接收常规参数，而累加器相对于那些参数和上下文而变化。

显然，与上一章中的任何一种设计方法相比，正确地使用累加器设计功能要复杂得多。关键是要了解适当的论点和累加器之间的关系。以下各章说明如何使用累加器设计功能以及它们如何工作。

## The Loss of Knowledge 

尽管结构方式不同，但根据结构配方设计的功能和生成功能都遭受了知识的损失。 本章通过两个示例（每个类别一个示例）说明缺少上下文知识如何影响功能的性能。 虽然第一部分是关于结构递归的，但第二部分是关于生成领域的关注。

### 31.1 A Problem with Structural Processing